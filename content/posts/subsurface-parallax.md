---
title: "On Subsurface Parallax Shading"
date: 2025-03-22
---

Recently I tried implementing a fake depth parallax shader. The basic idea I had is to make it look like the texture given is some depth $D$ units below the surface. The surface itself could vary in refractive index, maybe to make it look like it's encased in glass or resin.

First I started by drawing a diagram like this,

{{< image src="/assets/img/subsurface_diagram.png" position="center" style="border-width: 1px; width: 500px;" >}}

What we're looking for is that little offset $\mathbf{u}$.

Since we're working in terms of UV coordinates on the surface, it's helpful to think in terms of tangent space, so we have to transform our view direction by the inverse of the TBN matrix. As it's orthonormal, its inverse is its transpose.

$$
\mathbf{v} = \text{TBN}^\text{T} \cdot \text{worldspace view direction}
$$

Please make sure that when generating your TBN matrix, you're using all three components generated by your model importer of choice, not just computing the cross product of the first two. See [here]({% post_url 2025-03-23-demystifying-tbn %}) for details.

Working in tangent space means that $\mathbf{n} = (0, 0, 1)$, so $(\mathbf{n} \cdot \mathbf{v}) = v_3 = \cos \theta_o$. Now $\mathbf{u}$ can be found by doing some basic trigonometry,

$$
\mathbf{u} = -\frac{D}{v_3} \cdot \mathbf{v}_{12}
$$

If we want to do refraction it's as simple as refracting the view direction and then using that in the final $\mathbf{u}$ calculation,

$$
\mathbf{v}' = \text{refract}(\mathbf{v}, \mathbf{n}, \eta)
$$

So our parallax code looks like,

{{< code language="hlsl" open="true" >}}
float2 subsurface_parallax(float2 uv, float3 view_dir, float eta, float depth)
{
	float2 refracted_view_dir = refract(-view_dir, float3(0.0, 0.0, 1.0), eta);
	float2 u = depth / refracted_view_dir.z * refracted_view_dir.xy;
	return uv - u;
}
{{< /code >}}

We can then use this to sample our texture with the new UV coordinates as usual.
